#include <Keypad.h>

// ==== CONFIGURAÇÃO DO TECLADO ====
const byte LINHAS = 4;
const byte COLUNAS = 4;

// Mapeamento das teclas físicas
char teclas[LINHAS][COLUNAS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};

// Definição dos pinos do teclado matricial
byte pinosLinhas[LINHAS] = {9, 8, 7, 6};
byte pinosColunas[COLUNAS] = {5, 4, 3, 2};

// Instancia o teclado
Keypad teclado = Keypad(makeKeymap(teclas), pinosLinhas, pinosColunas, LINHAS, COLUNAS);


// ==== JOYSTICK ====
int eixoX = A0;              // eixo horizontal
int eixoY = A1;              // eixo vertical
int botaoJoystick = 12;      // botão (pressionar o analógico)


// ==== SENSORES ====
#define TRIG 10              // pino de trigger do sensor ultrassônico
#define ECHO 11              // pino de echo do sensor ultrassônico
#define SENSOR_NIVEL A2      // sensor analógico de nível


// ==== VARIÁVEIS DE CONTROLE ====
int modo = 0;                // 0 = nenhum modo; 1 = contínuo; 2 = sob demanda; 3 = teste
int distanciaLimite = 50;    // limite crítico de distância em cm
int nivelLimite = 400;       // limite crítico de nível de água (valor analógico)
unsigned long tempoAnterior = 0;  // controle de tempo para o modo contínuo


// ==== VARIÁVEIS DE LEITURA ====
long distanciaAtual = 0;
int nivelAtual = 0;


// ==== FUNÇÕES AUXILIARES ====

/**
 * Faz a leitura do sensor ultrassônico e retorna a distância em centímetros.
 */
long leDistancia() {
  digitalWrite(TRIG, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG, LOW);
  long duracao = pulseIn(ECHO, HIGH);
  return duracao * 0.034 / 2;  // converte tempo em distância (cm)
}

/**
 * Faz a leitura do sensor de nível de água (valor analógico 0–1023).
 */
int leNivelAgua() {
  return analogRead(SENSOR_NIVEL);
}


// ==== CONFIG/CALIBRAÇÃO E AÇÕES A/B/C/D ====
// (Colocado aqui antes de leTeclado(), pois leTeclado usa essas funções)

// parâmetros de calibração
const int AMOSTRAS_CAL = 20;     // nº de amostras para calibrar
const int MARGEM_DIST_CM = 5;    // margem de segurança para distância
const int MARGEM_NIVEL_RAW = 30; // margem mínima para nível (ADC)

// utilitários de média
template<typename T>
long mediaFiltradaUltrassom(int n, T leitor){
  long soma = 0; int validas = 0;
  for(int i=0;i<n;i++){
    long v = leitor();
    if(v > 0){ soma += v; validas++; }
    delay(10);
  }
  return validas ? (soma/validas) : 0;
}

template<typename T>
long mediaSimples(int n, T leitor){
  long soma = 0;
  for(int i=0;i<n;i++){ soma += leitor(); delay(5); }
  return soma / n;
}

// A) Calibrar distância (ultrassônico) -> define distanciaLimite
void calibraDistancia(){
  Serial.println(F("[A] Calibrando distancia..."));
  long media = mediaFiltradaUltrassom(AMOSTRAS_CAL, [](){ return leDistancia(); });
  if(media <= 0){
    Serial.println(F("Falha na calibracao: leituras invalidas (0). Verifique o sensor."));
    return;
  }
  distanciaLimite = (int)max(1L, media - MARGEM_DIST_CM);
  Serial.print(F("Distancia media = "));
  Serial.print(media);
  Serial.print(F(" cm -> limite ajustado para "));
  Serial.print(distanciaLimite);
  Serial.println(F(" cm"));
}

// B) Calibrar nível (analógico) -> define nivelLimite
void calibraNivel(){
  Serial.println(F("[B] Calibrando nivel..."));
  long media = mediaSimples(AMOSTRAS_CAL, [](){ return leNivelAgua(); });
  nivelLimite = (int)(media + MARGEM_NIVEL_RAW);
  Serial.print(F("Nivel medio = "));
  Serial.print(media);
  Serial.print(F(" (ADC) -> limite ajustado para "));
  Serial.print(nivelLimite);
  Serial.println(F(" (ADC)"));
  Serial.println(F("Dica: ajuste fino pode ser feito pelas teclas numericas (0-9)."));
}

// C) Diagnóstico rápido (estado do sistema)
void imprimeDiagnostico(){
  int x = analogRead(eixoX), y = analogRead(eixoY);
  leSensores();
  Serial.println(F("[C] Diagnostico rapido:"));
  Serial.print(F("Modo atual: ")); Serial.println(modo);
  Serial.print(F("Joystick X=")); Serial.print(x);
  Serial.print(F(" Y=")); Serial.println(y);
  Serial.print(F("Distancia atual: ")); Serial.print(distanciaAtual); Serial.println(F(" cm"));
  Serial.print(F("Nivel atual: ")); Serial.println(nivelAtual);
  Serial.print(F("Limites -> Distancia: ")); Serial.print(distanciaLimite);
  Serial.print(F(" cm | Nivel: ")); Serial.println(nivelLimite);
  Serial.println(F("Controles: '#' confirma modo | '*' aciona leitura (modo 2/3) | Clique do joystick reseta modo"));
}

// D) Reset do sistema (defaults e volta ao modo 0)
void resetSistema(){
  Serial.println(F("[D] Reset do sistema: restaurando parametros e modo..."));
  distanciaLimite = 50;
  nivelLimite = 400;
  modo = 0;
  tempoAnterior = millis();
  Serial.println(F("Parametros padrao: distancia=50 cm, nivel=400 (ADC). Mova o joystick para selecionar novo modo."));
}

// despachante das teclas funcionais A/B/C/D
void trataTeclaFuncional(char t){
  switch(t){
    case 'A': calibraDistancia();   break;
    case 'B': calibraNivel();       break;
    case 'C': imprimeDiagnostico(); break;
    case 'D': resetSistema();       break;
    default: break;
  }
}


// ==== LEITURA DO JOYSTICK ====

/**
 * Lê o joystick e define o modo de operação.
 * - Eixo X controla modos 1 e 2.
 * - Eixo Y seleciona o modo 3.
 * - Pressionar o analógico (botão) reseta o modo para 0.
 */
void leJoystick() {
  int x = analogRead(eixoX);
  int y = analogRead(eixoY);
  bool botaoPressionado = (digitalRead(botaoJoystick) == LOW);

  // Resetar modo ao pressionar o botão
  if (botaoPressionado) {
    modo = 0;
    Serial.println("Modo resetado. Escolha um novo modo com o joystick.");
    delay(300); // evita múltiplas leituras (debounce)
  }

  // Selecionar modo com o joystick (somente quando modo = 0)
  if (modo == 0) {
    if (x < 400) {
      Serial.println("Modo de monitoramento contínuo selecionado.");
      modo = 1;
    }
    else if (x > 600) {
      Serial.println("Modo sob demanda selecionado.");
      modo = 2;
    }
    else if (y < 400) {
      Serial.println("Modo de teste de sensores selecionado.");
      modo = 3;
    }
  }
}


// ==== LEITURA DO TECLADO ====

/**
 * Lê o teclado e ajusta parâmetros ou confirma ações.
 * - Teclas numéricas: definem o limite de distância.
 * - Tecla '#': confirma o modo.
 * - Tecla '*': executa leitura/teste (dependendo do modo).
 * - Teclas 'A','B','C','D': calibração/diagnóstico/reset.
 */
void leTeclado() {
  char tecla = teclado.getKey();
  if (!tecla) return; // nenhuma tecla pressionada

  // Atualizar limite de distância (0–9 → 0 a 90 cm)
  if (tecla >= '0' && tecla <= '9') {
    distanciaLimite = (tecla - '0') * 10;
    Serial.print("Parâmetro atualizado: distância crítica = ");
    Serial.print(distanciaLimite);
    Serial.println(" cm");
    return;
  }

  // Confirmar o modo selecionado
  if (tecla == '#') {
    Serial.print("Modo confirmado: ");
    Serial.println(modo);
    return;
  }

  // Executar ações conforme o modo atual com '*'
  if (tecla == '*') {
    if (modo == 2) { monitoraSensores(); return; }
    if (modo == 3) { testaSensores();    return; }
  }

  // Ações funcionais: A, B, C, D
  if (tecla=='A' || tecla=='B' || tecla=='C' || tecla=='D') {
    trataTeclaFuncional(tecla);
    return;
  }
}


// ==== LEITURA DOS SENSORES ====

/**
 * Atualiza as variáveis globais de distância e nível com os valores lidos.
 */
void leSensores() {
  distanciaAtual = leDistancia();
  nivelAtual = leNivelAgua();
}


// ==== EXIBIÇÃO DE RESULTADOS ====

/**
 * Mostra no monitor serial as leituras atuais
 * e emite alertas se estiverem fora dos limites.
 */
void exibeResultados() {
  Serial.print("Distância: ");
  Serial.print(distanciaAtual);
  Serial.print(" cm | Nível: ");
  Serial.println(nivelAtual);

  if (distanciaAtual < distanciaLimite) {
    Serial.println("ALERTA: distância inferior ao limite!");
  }
  if (nivelAtual > nivelLimite) {
    Serial.println("ALERTA: nível de água crítico!");
  }
}


// ==== MONITORAMENTO E TESTE ====

/**
 * Monitora os sensores e exibe os resultados.
 * Usado no modo contínuo e sob demanda.
 */
void monitoraSensores() {
  leSensores();
  exibeResultados();
}

/**
 * Testa os sensores individualmente para verificar se estão respondendo.
 * Usado no modo de teste.
 */
void testaSensores() {
  leSensores();
  Serial.print("Sensor ultrassônico OK — leitura: ");
  Serial.print(distanciaAtual);
  Serial.println(" cm");
  Serial.print("Sensor de nível OK — leitura: ");
  Serial.println(nivelAtual);
}


// ==== SETUP E LOOP PRINCIPAL ====

void setup() {
  Serial.begin(9600);
  pinMode(TRIG, OUTPUT);
  pinMode(ECHO, INPUT);
  pinMode(botaoJoystick, INPUT_PULLUP);

  Serial.println("Sistema iniciado. Use o joystick para escolher o modo.");
}

void loop() {
  // Leitura dos dispositivos de entrada
  leJoystick();
  leTeclado();

  // Modo contínuo: leitura automática a cada 2 segundos
  if (modo == 1 && millis() - tempoAnterior > 2000) {
    tempoAnterior = millis();
    monitoraSensores();
  }
}
